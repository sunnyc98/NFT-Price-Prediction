# -*- coding: utf-8 -*-
"""total_NFT_prediction.ipynb architecture 1 수정됨, 추가실험

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rl2q3acmlnahJOEwudqAkQMqDWPMEGql

# Importing Files
"""

import numpy as np
import matplotlib.pyplot as plt0_1
import matplotlib.pyplot as plt0_2
import pandas as pd

import matplotlib.pyplot as plt1
import matplotlib.pyplot as plt2
import matplotlib.pyplot as plt3

from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler


from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout
from keras.regularizers import L1L2

"""# Functions"""

def training(X_train, Y_train, case, epoch):
  regressor = Sequential()

  if case == 1:
    regressor.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units=50, return_sequences=True))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units=50))
    regressor.add(Dropout(0.2))

    regressor.add(Dense(units=1))

    regressor.compile(optimizer='adam', loss='mean_squared_error')

    regressor.fit(X_train, Y_train, epochs = epoch, batch_size=32)
    '''
    elif case == 2:
    regressor.add(LSTM(units = 128, return_sequences = True, input_shape = (X_train.shape[1], 1)))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units = 64, return_sequences = True))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units = 16))
    regressor.add(Dropout(0.2))

    regressor.add(Dense(units = 1))

    regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')
    regressor.fit(X_train, Y_train, epochs = epoch, batch_size = 32)
    
    '''
  elif case ==2 :
    regressor.add(LSTM(units = 128, return_sequences = True, input_shape = (X_train.shape[1], 1), recurrent_regularizer = L1L2(l1=0.01, l2=0.0)))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units = 64, return_sequences = True, recurrent_regularizer = L1L2(l1=0.0, l2=0.01)))
    regressor.add(Dropout(0.2))

    regressor.add(LSTM(units = 16))
    regressor.add(Dropout(0.2))

    regressor.add(Dense(units = 1))

    regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')
    regressor.fit(X_train, Y_train, epochs = epoch, batch_size = 32)
    
  else:
    print("Wrong parameter!! Only 1, 2.")
  return regressor

# [, -1.5), [-1.5, -0.5), [-0.5, 0.4), [0.4, 1.4), [1.4, 2.5), [2.5, 4.3), [4.3, ] (%)
def categorization_1(standard_prev_val, raw_arr, standard_arr):
    r, _ = raw_arr.shape
    cate_arr = np.zeros(r)
    for i in range(r):
        if i == 0:
            a = ((raw_arr[0] - standard_prev_val) * 100) / standard_prev_val
        else:
            a = ((raw_arr[i] - standard_arr[i - 1]) * 100) / standard_arr[i - 1]

        if a < -1.5:
            cate_arr[i] = 0
        elif a < -0.5:
            cate_arr[i] = 1
        elif a < 0.4:
            cate_arr[i] = 2
        elif a < 1.4:
            cate_arr[i] = 3
        elif a < 2.5:
            cate_arr[i] = 4
        elif a < 4.3:
            cate_arr[i] = 5
        else:
            cate_arr[i] = 6
    return cate_arr


# Only 0 and 1.
def categorization_2(standard_prev_val, raw_arr, standard_arr):
    r, _ = raw_arr.shape
    cate_arr = np.zeros(r)
    for i in range(r):
        if i == 0:
            a = raw_arr[0] - standard_prev_val
        else:
            a = raw_arr[i] - standard_arr[i - 1]
        if a < 0:
            cate_arr[i] = 0
        else:
            cate_arr[i] = 1
    return cate_arr


def optimistical_categorization(prev_val, raw_arr):
  r, _ = raw_arr.shape
  cate_arr = np.zeros( r )
  cate_arr[0] = 0
  for i in range(r-1):
    if i==0:
      a = ((raw_arr[0] - prev_val ) * 100) / prev_val
    else:
      a = ((raw_arr[i] - raw_arr[i-1] ) * 100) / raw_arr[i-1]
    if a < 0:
      cate_arr[i+1] = 0
    else:
      cate_arr[i+1] = 1
  return cate_arr

def metrics( real, pred ):
    true_positive = 0
    true_negative = 0
    false_positive = 0
    false_negative = 0
    for i in range(len(real)):
        true_positive += (real[i] == pred[i]) and pred[i] == 1
        true_negative += (real[i] == pred[i]) and pred[i] == 0
        false_positive += (real[i] != pred[i]) and pred[i] == 1
        false_negative += (real[i] != pred[i]) and pred[i] == 0
    acc = ( true_positive + true_negative) / ( true_positive + true_negative + false_positive + false_negative )
    precision = true_positive / (true_positive + false_positive)
    recall = true_positive / (true_positive + false_negative)
    f1 = 2 * (recall * precision )/ (recall + precision)
    return ( (true_positive, true_negative, false_positive, false_negative), acc, precision, recall, f1 )


def total_invest_and_return(prev_val, real_val_arr, pred_cate):
    investment = 0
    return_ = 0

    real_val_arr = real_val_arr.reshape(len(real_val_arr))
    pred_cate = pred_cate.reshape(len(pred_cate))

    for i in range(len(real_val_arr)):
        if i == 0:
            if pred_cate[i] == 0:
                pass
            else:
                investment += prev_val
        else:
            if pred_cate[i] == 0:
                if pred_cate[i - 1] == 0:
                    pass
                else:
                    return_ += real_val_arr[i]
            else:
                if pred_cate[i - 1] == 0:
                    investment += real_val_arr[i]
                else:
                    pass
    if real_val_arr[-1] == 1:
        return_ += real_val_arr[i - 1]
    return (investment, return_)


def operational_invest_and_return(prev_val, real_val_arr, pred_cate):
    prev_invest = 0
    operation_n = 0
    total_return_percentage = 0

    real_val_arr = real_val_arr.reshape(len(real_val_arr))
    pred_cate = pred_cate.reshape(len(pred_cate))

    for i in range(len(real_val_arr)):
        if i == 0:
            if pred_cate[i] == 0:
                pass
            else:
                prev_invest = prev_val
        else:
            if pred_cate[i] == 0:
                if pred_cate[i - 1] == 0:
                    pass
                else:
                    operation_n += 1
                    total_return_percentage += (100 * (real_val_arr[i] - prev_invest)) / prev_invest
            else:
                if pred_cate[i - 1] == 0:
                    prev_invest = real_val_arr[i]
                else:
                    pass
    print(total_return_percentage)
    print(operation_n)
    return total_return_percentage / operation_n


def maximum_drawdown(prev_val, real_val_arr, pred_cate):
    prev_invest = 0
    max_loss = 0

    real_val_arr = real_val_arr.reshape(len(real_val_arr))
    pred_cate = pred_cate.reshape(len(pred_cate))

    for i in range(len(real_val_arr)):
        if i == 0:
            if pred_cate[i] == 0:
                pass
            else:
                prev_invest = prev_val
        else:
            if pred_cate[i] == 0:
                if pred_cate[i - 1] == 0:
                    pass
                else:
                    return_ = real_val_arr[i] - prev_invest
                    if return_ < 0:
                        if max_loss > return_:
                            max_loss = return_
            else:
                if pred_cate[i - 1] == 0:
                    prev_invest = real_val_arr[i]
                else:
                    pass
    return max_loss

"""# Function for One cycle"""

def one_cycle(s_category, s_category_plot ,nonzero_index):
    print("Category is: ", s_category)
    #Loading Data
    dataset_train = pd.read_csv(s_category + '.csv')
    training_set = dataset_train.iloc[:, 2:3].values

    #what kind of dataset are we working with?
    print(s_category)
    dataset_train.head()

    #Feature Scaling
    sc = MinMaxScaler(feature_range=(0, 1))

    training_set_scaled = sc.fit_transform(training_set)

    X_train = []
    y_train = []
    r, c = training_set.shape
    test_n = (r - nonzero_index) - int((r - nonzero_index) * 0.75)
    train_interval_n = 60
    print("total data except zero: ", r - nonzero_index, ", training set: ", int((r - nonzero_index) * 0.75),
          ", test set: ", test_n, ", training interval(sequence length): ", train_interval_n)
    for i in range(train_interval_n, r - test_n):
        X_train.append(training_set_scaled[i - train_interval_n:i, 0])
        y_train.append(training_set_scaled[i, 0])
    X_train, y_train = np.array(X_train), np.array(y_train)

    X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))


    #Building the LSTM of all four cases
    regressor3 = training(X_train, y_train, 2, 200)
    regressor4 = training(X_train, y_train, 2, 500)


    #Prediction using Test set
    real_stock_price = training_set[r - test_n:]
    inputs = training_set[r - test_n - train_interval_n:]

    inputs = inputs.reshape(-1, 1)
    inputs = sc.transform(inputs)
    print(inputs.shape)

    X_test = []
    print(test_n + train_interval_n)
    for i in range(train_interval_n, test_n + train_interval_n):
        X_test.append(inputs[i - train_interval_n:i, 0])
    X_test = np.array(X_test)
    X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))


    predicted_stock_price3 = regressor3.predict(X_test)
    predicted_stock_price3 = sc.inverse_transform(predicted_stock_price3)
    predicted_stock_price4 = regressor4.predict(X_test)
    predicted_stock_price4 = sc.inverse_transform(predicted_stock_price4)

    #Plotting the Results
    

    plt0_2.plot(real_stock_price, color='black', label='Real Price(Average USD)')
    plt0_2.plot(predicted_stock_price3, color='green', label='Predicted NFT Price(Average USD), Epoch 200')
    plt0_2.plot(predicted_stock_price4, color='blue', label='Predicted NFT Price(Average USD), Epoch 500')
    plt0_2.title('Architecture 2\n'+'Predicted ' + s_category_plot + ' NFT Price(Average USD)')
    plt0_2.xlabel('Days')
    plt0_2.ylabel(s_category_plot + ' NFT Price(Average USD)')
    plt0_2.legend()
    plt0_2.show()

    real_cate_stock_price_1 = categorization_1(training_set[r - test_n - 1][0], real_stock_price, real_stock_price)
    
    predicted_cate_stock_price_1_3 = categorization_1(training_set[r - test_n - 1][0], predicted_stock_price3, real_stock_price)
    predicted_cate_stock_price_1_4 = categorization_1(training_set[r - test_n - 1][0], predicted_stock_price4, real_stock_price)

    # Calculate Accuracy(by 7 categories)
    
    z3 = real_cate_stock_price_1 - predicted_cate_stock_price_1_3
    acc_cate_stock_price_1_3 = (z3 == 0).sum() / len(z3)
    z4 = real_cate_stock_price_1 - predicted_cate_stock_price_1_4
    acc_cate_stock_price_1_4 = (z4 == 0).sum() / len(z4)


    # Start Calculate for binary categories
    real_cate_stock_price_2 = categorization_2(training_set[r - test_n - 1][0], real_stock_price, real_stock_price)
    
    predicted_cate_stock_price_2_3 = categorization_2(training_set[r - test_n - 1][0], predicted_stock_price3, real_stock_price)
    predicted_cate_stock_price_2_4 = categorization_2(training_set[r - test_n - 1][0], predicted_stock_price4, real_stock_price)
    optimal_cate_stock_price_2 = optimistical_categorization(training_set[r - test_n - 1][0], real_stock_price)
    random_cate_stock_price_2 = np.random.randint(2, size=len(real_cate_stock_price_2))

    # Calculate Metrics
    
    _, lstm_acc_3, lstm_precision_3, lstm_recall_3, lstm_f1_3 = metrics(real_cate_stock_price_2, predicted_cate_stock_price_2_3)
    _, lstm_acc_4, lstm_precision_4, lstm_recall_4, lstm_f1_4 = metrics(real_cate_stock_price_2, predicted_cate_stock_price_2_4)
    _, random_acc, random_precision, random_recall, random_f1 = metrics(real_cate_stock_price_2, random_cate_stock_price_2)
    _, optimal_acc, optimal_precision, optimal_recall, optimal_f1 = metrics(real_cate_stock_price_2, optimal_cate_stock_price_2)

    """#Calculate Accuracy based in MSE"""
    
    print(s_category, " [Architecture 2, Epoch 200] MSE(real value): ", mean_squared_error(real_stock_price, predicted_stock_price3), ", RSME: ",
          np.sqrt(mean_squared_error(real_stock_price, predicted_stock_price3)))
    print(s_category, " [Architecture 2, Epoch 500] MSE(real value): ", mean_squared_error(real_stock_price, predicted_stock_price4), ", RSME: ",
          np.sqrt(mean_squared_error(real_stock_price, predicted_stock_price4)))
    print()
    
    print(s_category, " [Architecture 2, Epoch 200] MSE(binary categorized value LSTM): ",
          mean_squared_error(real_cate_stock_price_2, predicted_cate_stock_price_2_3), ", RSME: ",
          np.sqrt(mean_squared_error(real_cate_stock_price_2, predicted_cate_stock_price_2_3)))
    print(s_category, " [Architecture 1, Epoch 500] MSE(binary categorized value LSTM): ",
          mean_squared_error(real_cate_stock_price_2, predicted_cate_stock_price_2_4), ", RSME: ",
          np.sqrt(mean_squared_error(real_cate_stock_price_2, predicted_cate_stock_price_2_4)))
    print(s_category, " MSE(binary categorized, optimal): ",
          mean_squared_error(real_cate_stock_price_2, optimal_cate_stock_price_2), ", RSME: ",
          np.sqrt(mean_squared_error(real_cate_stock_price_2, optimal_cate_stock_price_2)))
    print(s_category, " MSE(binary categorized, random): ",
          mean_squared_error(real_cate_stock_price_2, random_cate_stock_price_2), ", RSME: ",
          np.sqrt(mean_squared_error(real_cate_stock_price_2, random_cate_stock_price_2)))
    print()
    
    print(s_category, " [Architecture 2, Epoch 200] Accuracy(by 7 categories): ", acc_cate_stock_price_1_3)
    print(s_category, " [Architecture 2, Epoch 500] Accuracy(by 7 categories): ", acc_cate_stock_price_1_4)
    print()
    print()
    print(s_category)
    print()
    print("lstm")
    
    print(" [Architecture 2, Epoch 200] \nAccuracy: ", lstm_acc_3, "\nPrecision: ", lstm_precision_3, "\nRecall: ", lstm_recall_3, "\nF1: ", lstm_f1_3)
    print(" [Architecture 2, Epoch 500] \nAccuracy: ", lstm_acc_4, "\nPrecision: ", lstm_precision_4, "\nRecall: ", lstm_recall_4, "\nF1: ", lstm_f1_4)
    print()
    print("random")
    print("Accuracy: ", random_acc, "\nPrecision: ", random_precision, "\nRecall: ", random_recall, "\nF1: ", random_f1)
    print()
    print("optimal")
    print("Accuracy: ", optimal_acc, "\nPrecision: ", optimal_precision, "\nRecall: ", optimal_recall, "\nF1: ", optimal_f1)
    print()
    print()

    # LSTM
    
    

    lstm_total_investment_3, lstm_total_return_3 = total_invest_and_return(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_3)
    lstm_total_return_investment_3 = 100 * (lstm_total_return_3 - lstm_total_investment_3) / lstm_total_investment_3
    lstm_operational_return_3 = operational_invest_and_return(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_3)
    lstm_maxdrawdown_3 = maximum_drawdown(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_3)

    lstm_total_investment_4, lstm_total_return_4 = total_invest_and_return(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_4)
    lstm_total_return_investment_4 = 100 * (lstm_total_return_4 - lstm_total_investment_4) / lstm_total_investment_4
    lstm_operational_return_4 = operational_invest_and_return(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_4)
    lstm_maxdrawdown_4 = maximum_drawdown(training_set[r - test_n - 1][0], real_stock_price, predicted_cate_stock_price_2_4)

    # Optimal
    optimal_total_investment, optimal_total_return = total_invest_and_return(training_set[r - test_n - 1][0],
                                                                             real_stock_price,
                                                                             optimal_cate_stock_price_2)
    optimal_total_return_investment = 100 * (optimal_total_return - optimal_total_investment) / optimal_total_investment
    optimal_operational_return = operational_invest_and_return(training_set[r - test_n - 1][0], real_stock_price,
                                                               optimal_cate_stock_price_2)
    optimal_maxdrawdown = maximum_drawdown(training_set[r - test_n - 1][0], real_stock_price,
                                           optimal_cate_stock_price_2)

    # Random
    random_total_investment, random_total_return = total_invest_and_return(training_set[r - test_n - 1][0],
                                                                           real_stock_price, random_cate_stock_price_2)
    random_total_return_investment = 100 * (random_total_return - random_total_investment) / random_total_investment
    random_operational_return = operational_invest_and_return(training_set[r - test_n - 1][0], real_stock_price,
                                                              random_cate_stock_price_2)
    random_maxdrawdown = maximum_drawdown(training_set[r - test_n - 1][0], real_stock_price, random_cate_stock_price_2)

    # Buy and Hold
    bah_total_investment = real_stock_price[0][0]
    bah_total_return = real_stock_price[-1][0]
    bah_total_return_investment = 100 * (bah_total_return - bah_total_investment) / bah_total_investment

    # Print results
    print(s_category)
    print("[LSTM]", "\n [Architecture 2, Epoch 200] Total return: ", lstm_total_return_investment_3,
          "%, Average financial return / Investment Per Operation: ", lstm_operational_return_3, "%, Maximum drawdown: ",
          lstm_maxdrawdown_3)
    print(" [Architecture 2, Epoch 500] Total return: ", lstm_total_return_investment_4,
          "%, Average financial return / Investment Per Operation: ", lstm_operational_return_4, "%, Maximum drawdown: ",
          lstm_maxdrawdown_4)
    
    print("[Optimal]", "Total return: ", optimal_total_return_investment,
          "%, Average financial return / Investment Per Operation: ", optimal_operational_return,
          "%, Maximum drawdown: ", optimal_maxdrawdown)
    print("[Random]", "Total return: ", random_total_return_investment,
          "%, Average financial return / Investment Per Operation: ", random_operational_return,
          "%, Maximum drawdown: ", random_maxdrawdown)
    print("[Buy and Hold]", "Total return: ", bah_total_return_investment, "%")

    # Plot the comparison
    '''
    x1 = np.arange(7)
    archi_1 = ["LSTM(A)", "LSTM(B)","LSTM(C)","LSTM(D)","Optimal", "B&H", "Random"]

    x2 = np.arange(6)
    archi_2 = ["LSTM(A)", "LSTM(B)","LSTM(C)","LSTM(D)","Optimal", "Random"]

    plt1.xticks(x1, archi_1)
    plt1.bar(x1, [lstm_total_return_investment_1, lstm_total_return_investment_2, lstm_total_return_investment_3, lstm_total_return_investment_4,optimal_total_return_investment, random_total_return_investment,
                  bah_total_return_investment], color=['r','r','r','r', 'g', 'b', 'y'], width=0.4)
    plt1.title("[" + s_category + "] Returns (%) ")
    plt1.show()

    plt2.xticks(x2, archi_2)
    plt2.bar(x2, [lstm_operational_return_1, lstm_operational_return_2, lstm_operational_return_3, lstm_operational_return_4, optimal_operational_return, random_operational_return],
             color=['r', 'r','r','r','g', 'y'], width=0.5)
    plt2.title("[" + s_category + "] Average return per operation (%) ")
    plt2.show()

    plt3.xticks(x2, archi_2)
    plt3.bar(x2, [lstm_maxdrawdown_1, lstm_maxdrawdown_2, lstm_maxdrawdown_3, lstm_maxdrawdown_4, optimal_maxdrawdown, random_maxdrawdown], color=['r', 'r','r','r','g', 'y'], width=0.5)
    plt3.title("[" + s_category + "] Maximum Drawdown ")
    plt3.show()
    
    '''

"""#For each case, run the cycle function

art_blocks_art
"""

one_cycle("art_blocks_art", "art blocks art",0)

"""creepz_game"""

one_cycle("creepz_game", "creepz game",0)

"""the_sandbox_metaverse"""

one_cycle("the_sandbox_metaverse","the sandbox metaverse" ,2)

"""superrare_art"""

one_cycle("superrare_art","superrare art", 276)

"""bored_ape_yacht_club_collection"""

one_cycle("bored_ape_yacht_club_collection","bored ape yacht club collection" ,0)

"""axie_infinity_game


"""

one_cycle("axie_infinity_game", "axie infinity game",38)

"""crypto_punk_collection"""

one_cycle( "crypto_punk_collection", "crypto punk collection",1)

"""decentraland_metaverse"""

one_cycle("decentraland_metaverse", "decentraland metaverse",171)